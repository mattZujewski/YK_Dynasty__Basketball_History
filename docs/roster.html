<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rosters &mdash; YK Dynasty Basketball</title>
  <script>if(localStorage.getItem('yk_theme')==='dark')document.documentElement.classList.add('dark');</script>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <script src="js/nav.js"></script>

  <main class="page-container">
    <header class="page-header">
      <h1>&#x1F4DD; Current Rosters</h1>
      <p class="subtitle" id="roster-subtitle">Loading&hellip;</p>
    </header>

    <!-- Stat Bar -->
    <div class="stat-bar" id="roster-stats">
      <div class="stat-card">
        <span class="stat-label">Franchises</span>
        <span class="stat-value gold">10</span>
      </div>
      <div class="stat-card">
        <span class="stat-label">Total Players</span>
        <span class="stat-value" id="stat-total-players">&mdash;</span>
      </div>
      <div class="stat-card">
        <span class="stat-label">Avg Roster Size</span>
        <span class="stat-value" id="stat-avg-roster">&mdash;</span>
      </div>
      <div class="stat-card">
        <span class="stat-label">Ranked Players</span>
        <span class="stat-value gold" id="stat-ranked">&mdash;</span>
      </div>
    </div>

    <!-- Roster Grid -->
    <div id="roster-grid" class="roster-grid">
      <div class="loading-spinner" style="text-align:center;padding:40px;color:var(--text-muted)">Loading&hellip;</div>
    </div>

    <!-- Fallback message if no data -->
    <div class="chart-section" id="no-data-msg" style="display:none">
      <h2>No Roster Data Available</h2>
      <p class="chart-description">
        Roster data hasn't been fetched yet. Run the Fantrax API script to populate:
      </p>
      <pre style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:16px;overflow-x:auto;font-size:0.85rem;color:var(--text-primary)">python3 scripts/fantrax_yk.py --season 2025-26</pre>
    </div>
  </main>

  <script src="js/charts.js"></script>
  <script>
    (async function () {
      const YK = window.YK;
      const grid = document.getElementById('roster-grid');

      let rosterData, seasonsData, rankingsData;
      try {
        [rosterData, seasonsData, rankingsData] = await Promise.all([
          YK.loadJSON('data/rosters_2025_26.json'),
          YK.loadJSON('data/seasons.json'),
          YK.loadJSON('data/rankings.json'),
        ]);
      } catch (e) {
        console.warn('No roster data found:', e);
        grid.style.display = 'none';
        document.getElementById('no-data-msg').style.display = 'block';
        return;
      }

      const teams = rosterData.teams || {};
      const ownerKeys = Object.keys(teams);

      if (ownerKeys.length === 0) {
        grid.style.display = 'none';
        document.getElementById('no-data-msg').style.display = 'block';
        return;
      }

      // Dynamic subtitle
      document.getElementById('roster-subtitle').innerHTML =
        `${rosterData.season || '2025&ndash;26'} rosters pulled from Fantrax`;

      // Build standings rank map for 2025-26
      const currentSeason = seasonsData.seasons.find(s => s.year === '2025-26');
      const standingsRank = {};
      const standingsRecord = {};
      if (currentSeason) {
        currentSeason.standings.forEach(entry => {
          const owner = YK.teamToOwner(entry.team);
          if (owner) {
            standingsRank[owner] = entry.rank;
            standingsRecord[owner] = { w: entry.w, l: entry.l, pct: entry.win_pct };
          }
        });
      }

      // Build rankings lookup (accent-normalized)
      function normalizeName(str) {
        return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase().trim();
      }
      const rankMap = {};
      (rankingsData.rankings || []).forEach(r => {
        rankMap[normalizeName(r.player)] = r.rank;
      });

      // Sort owners by standings rank (best first), unranked at end
      const sortedOwners = ownerKeys.slice().sort((a, b) => {
        const ra = standingsRank[a] || 99;
        const rb = standingsRank[b] || 99;
        return ra - rb;
      });

      // Status badge helper
      function statusBadge(status) {
        if (!status) return '';
        switch (status.toUpperCase()) {
          case 'ACTIVE':          return '<span class="badge badge-active">Active</span>';
          case 'RESERVE':         return '<span class="badge badge-reserve">Reserve</span>';
          case 'INJURED_RESERVE': return '<span class="badge badge-ir">IR</span>';
          case 'MINORS':          return '<span class="badge badge-minors">Minors</span>';
          default:                return '<span class="badge">' + escapeHtml(status) + '</span>';
        }
      }

      // Stat bar
      let totalPlayers = 0;
      let rankedOnRosters = 0;
      sortedOwners.forEach(key => {
        const players = teams[key].players || [];
        totalPlayers += players.length;
        players.forEach(p => {
          if (rankMap[normalizeName(p.name)] !== undefined) rankedOnRosters++;
        });
      });
      document.getElementById('stat-total-players').textContent = totalPlayers;
      document.getElementById('stat-avg-roster').textContent =
        ownerKeys.length > 0 ? (totalPlayers / ownerKeys.length).toFixed(1) : '—';
      document.getElementById('stat-ranked').textContent = rankedOnRosters;

      // Build roster cards
      let html = '';
      sortedOwners.forEach(ownerKey => {
        const team = teams[ownerKey];
        const color = YK.ownerColor(ownerKey);
        const displayName = YK.ownerDisplayName(ownerKey);
        const teamName = team.team_name || '—';
        const players = (team.players || []).slice();

        // Sort players: ranked first (by rank ascending), then unranked alphabetically
        players.sort((a, b) => {
          const ra = rankMap[normalizeName(a.name)];
          const rb = rankMap[normalizeName(b.name)];
          if (ra !== undefined && rb !== undefined) return ra - rb;
          if (ra !== undefined) return -1;
          if (rb !== undefined) return 1;
          return a.name.localeCompare(b.name);
        });

        const rec = standingsRecord[ownerKey];
        const recordStr = rec ? rec.w + '-' + rec.l + ' (' + (rec.pct * 100).toFixed(1) + '%)' : '';

        html += '<div class="roster-card" style="border-top:3px solid ' + color + '">';
        html += '<div class="roster-card-header">';
        html += '<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:' + color + ';margin-right:8px;vertical-align:middle"></span>';
        html += '<strong>' + displayName + '</strong>';
        html += '<span style="color:var(--text-muted);font-size:0.82rem;margin-left:8px">' + teamName + '</span>';
        if (rec) {
          html += '<span style="margin-left:auto;font-size:0.78rem;font-weight:700;color:var(--brand-green)">' + recordStr + '</span>';
        } else {
          html += '<span style="margin-left:auto"></span>';
        }
        html += '<span class="badge badge-active" style="margin-left:10px;font-size:0.72rem">' + players.length + '</span>';
        html += '</div>';
        html += '<div class="roster-card-body">';

        if (players.length === 0) {
          html += '<div style="color:var(--text-muted);padding:12px;text-align:center;font-style:italic">No player data available</div>';
        } else {
          html += '<table class="roster-player-table">';
          html += '<thead><tr><th>Player</th><th>Pos</th><th>Team</th><th>Status</th></tr></thead>';
          html += '<tbody>';
          players.forEach(p => {
            const rank = rankMap[normalizeName(p.name)];
            const rankBadge = rank !== undefined
              ? ' <span style="background:rgba(232,184,75,0.18);color:#c7960a;font-size:0.68rem;font-weight:800;padding:1px 5px;border-radius:99px;margin-left:4px">#' + rank + '</span>'
              : '';
            html += '<tr>';
            html += '<td><strong>' + escapeHtml(p.name) + '</strong>' + rankBadge + '</td>';
            html += '<td style="color:var(--text-muted)">' + escapeHtml(p.pos || '—') + '</td>';
            html += '<td style="color:var(--text-muted)">' + escapeHtml(p.nbaTeam || '—') + '</td>';
            html += '<td>' + statusBadge(p.status) + '</td>';
            html += '</tr>';
          });
          html += '</tbody></table>';
        }

        html += '</div></div>';
      });

      grid.innerHTML = html;

      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }
    })();
  </script>

  <style>
    .roster-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .roster-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    .roster-card-header {
      display: flex;
      align-items: center;
      padding: 14px 18px;
      background: var(--bg-secondary, var(--bg-card));
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
      gap: 4px;
    }
    .roster-card-body {
      max-height: 480px;
      overflow-y: auto;
    }
    .roster-player-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82rem;
    }
    .roster-player-table th {
      position: sticky;
      top: 0;
      background: var(--bg-card);
      padding: 6px 12px;
      text-align: left;
      font-weight: 600;
      color: var(--text-muted);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid var(--border);
    }
    .roster-player-table td {
      padding: 5px 12px;
      border-bottom: 1px solid var(--border);
    }
    .roster-player-table tbody tr:hover {
      background: var(--bg-hover, rgba(0,0,0,0.02));
    }
    @media (max-width: 720px) {
      .roster-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</body>
</html>
